//
//  DetailsShowTVInteractor.swift
//  AppMovies
//
//  Created Roberto Antonio Alba Hernández on 19/02/23.
//  Copyright © 2023 ___ORGANIZATIONNAME___. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import CoreData

class DetailsShowTVInteractor: DetailsShowTVInteractorProtocol {
    weak var presenter: DetailsShowTVPresenterProtocol?
    
    func getProviders(idShowTV: Int?, completion: @escaping ((WatchTVProviders?) -> ())) {
        
        let params = ["api_key":APIManager.API_KEY]
        
        
        
//        APIManager.fetchObject(apiURL: APIURL.COUNTRIES, parameters: params) { (object : GenresTV?, error:APIError?) in
//
//        }
        
        APIManager.fetchObject(apiURL: APIURL.PROVIDERS_TV(idShowTV: idShowTV ?? 0), parameters: params) { (object : WatchTVProviders?, error : APIError?) in
            
            if let object = object {
                completion(object)
            } else {
                completion(nil)
            }
        }
    }
    
    func getProviders(idShowTV: Int?,completionHandler:@escaping (_ objects: [String : AnyObject]?, _ error: APIError?)->Void)   {
        
        
        APIManager.apiURLSelected = APIURL.PROVIDERS_TV(idShowTV: idShowTV ?? 0)
        
       
        let urlString =  APIManager.apiURLSelected?.url ?? ""
        
        let parameters = ["api_key":APIManager.API_KEY]
        
        var components = URLComponents(string: urlString)
        
        components?.queryItems = parameters.map { (key, value) in
            URLQueryItem(name: key, value: value)
        }
        
        
        var request = URLRequest(url: (components?.url!)!, cachePolicy: URLRequest.CachePolicy.useProtocolCachePolicy, timeoutInterval: 0.0)
        
        request.httpMethod = "GET"
        
        let task = URLSession.shared.dataTask(with: request) { (data, response, error) in
            
            if let error = error {
                print(error)
                completionHandler(nil,APIError.requestFailed)
                return
            }
            
            guard let response = response as? HTTPURLResponse
            else {
                print ("server response error")
                completionHandler(nil,APIError.requestFailed)
                return
            }
            
            
            if response.statusCode == 200{
                DispatchQueue.main.async {
                    do{
                        print(data!)
                        let json = try JSONSerialization.jsonObject(with: data!, options: .mutableContainers)
                        
                        print(json)
                        
                        
                        let dictionary = json as? [String : AnyObject]
                        
                        print(dictionary)
                        
                        
                        
                        completionHandler(dictionary,nil)
                        
                        
                        
                        
                    } catch let jsonError {
                        print(jsonError)
                        completionHandler(nil,APIError.jsonParsingFailure)
                    }
                    
                    //                    completionHandler(object,nil)
                    
                }
                
            }
            
            //            completionHandler(object,nil)
        }
        
        task.resume()

    }
    
    func isFavorite(idShowTV: Int) -> Bool? {
        let appDelegate = UIApplication.shared.delegate as! AppDelegate
        let context = appDelegate.persistentContainer.viewContext
        
        let fetchRequest: NSFetchRequest<Favorite> = Favorite.fetchRequest()
        
        do {
            fetchRequest.predicate = NSPredicate(format: "idShow == %d", idShowTV)
            let fetchedResults = try context.fetch(fetchRequest)
            if fetchedResults.first != nil {
                return true
            }
            
            return false
        } catch {
            print("Unable to Fetch Workouts, (\(error))")
            return false
        }
    }
    
    func addToFavorites(showTV: Result) -> Bool? {
        let appDelegate = UIApplication.shared.delegate as! AppDelegate
        let context = appDelegate.persistentContainer.viewContext
        
        let entityDescription = NSEntityDescription.entity(forEntityName: "Favorite", in: context)
        
        if let entityDescription = entityDescription {
            let favorite = Favorite(entity: entityDescription, insertInto: context)
            
            favorite.idShow = Int64(showTV.id ?? 0)
            favorite.name = showTV.name
            favorite.firstAirDate = showTV.firstAirDate
            favorite.overview = showTV.overview
            favorite.voteAverage = showTV.voteAverage ?? 0
            favorite.posterPath = showTV.posterPath
            
            do {
                try context.save()
                return true
            } catch let error {
                print(error)
                return false
            }
        }
        return false
    }
    
    func removeOfavorites(idShowTV: Int) -> Bool? {
        let appDelegate = UIApplication.shared.delegate as! AppDelegate
        let context = appDelegate.persistentContainer.viewContext
        
        let fetchRequest: NSFetchRequest<Favorite> = Favorite.fetchRequest()
        
        do {
            fetchRequest.predicate = NSPredicate(format: "idShow == %d", idShowTV)
            let fetchedResults = try context.fetch(fetchRequest)
            
            if let favorite = fetchedResults.first {
                context.delete(favorite)
                
                try context.save()
                return true
            }
            
            return false
        } catch {
            print("Unable to Fetch Workouts, (\(error))")
            return false
        }
    }
}
